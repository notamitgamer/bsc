/*
 * Author  : Amit Dutta <amitdutta4255@gmail.com>
 * Date    : 08 Feb 2026
 * Repo    : https://github.com/notamitgamer/bsc
 * License : MIT License (See the LICENSE file for details)
 * Copyright (c) 2026 Amit Dutta
 */

/* Obtain MD5 checksum of the following strings and check whether they are same:
"Six slippery snails slid slowly seaward."
"Six silppery snails slid slowly seaward."
*/
/* Let Us C, Chap- 23 (Security Programming), Qn No.: D(a) */

/* This file is auto-generated by a bot. */
/* This code is not compiled; it is for reference only. */


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* * Self-contained MD5 Implementation
 * Based on the public domain reference implementation (RFC 1321) logic.
 */

// --- MD5 Implementation Start ---
typedef struct {
    uint64_t size;        // Size of input in bytes
    uint32_t buffer[4];   // Current accumulation of hash
    uint8_t input[64];    // Input to be processed
} MD5Context;

#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

#define ROTL(x, s) (((x) << (s)) | ((x) >> (32 - (s))))

#define STEP(f, a, b, c, d, x, t, s) \
    (a) += f((b), (c), (d)) + (x) + (t); \
    (a) = ROTL((a), (s)); \
    (a) += (b);

void md5Transform(uint32_t state[4], const uint8_t block[64]) {
    uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
    int i, j;

    // Decode block into x
    for (i = 0, j = 0; j < 64; i++, j += 4)
        x[i] = ((uint32_t)block[j]) | (((uint32_t)block[j + 1]) << 8) |
               (((uint32_t)block[j + 2]) << 16) | (((uint32_t)block[j + 3]) << 24);

    // Round 1
    STEP(F, a, b, c, d, x[0], 0xd76aa478, 7);
    STEP(F, d, a, b, c, x[1], 0xe8c7b756, 12);
    STEP(F, c, d, a, b, x[2], 0x242070db, 17);
    STEP(F, b, c, d, a, x[3], 0xc1bdceee, 22);
    STEP(F, a, b, c, d, x[4], 0xf57c0faf, 7);
    STEP(F, d, a, b, c, x[5], 0x4787c62a, 12);
    STEP(F, c, d, a, b, x[6], 0xa8304613, 17);
    STEP(F, b, c, d, a, x[7], 0xfd469501, 22);
    STEP(F, a, b, c, d, x[8], 0x698098d8, 7);
    STEP(F, d, a, b, c, x[9], 0x8b44f7af, 12);
    STEP(F, c, d, a, b, x[10], 0xffff5bb1, 17);
    STEP(F, b, c, d, a, x[11], 0x895cd7be, 22);
    STEP(F, a, b, c, d, x[12], 0x6b901122, 7);
    STEP(F, d, a, b, c, x[13], 0xfd987193, 12);
    STEP(F, c, d, a, b, x[14], 0xa679438e, 17);
    STEP(F, b, c, d, a, x[15], 0x49b40821, 22);

    // Round 2
    STEP(G, a, b, c, d, x[1], 0xf61e2562, 5);
    STEP(G, d, a, b, c, x[6], 0xc040b340, 9);
    STEP(G, c, d, a, b, x[11], 0x265e5a51, 14);
    STEP(G, b, c, d, a, x[0], 0xe9b6c7aa, 20);
    STEP(G, a, b, c, d, x[5], 0xd62f105d, 5);
    STEP(G, d, a, b, c, x[10], 0x02441453, 9);
    STEP(G, c, d, a, b, x[15], 0xd8a1e681, 14);
    STEP(G, b, c, d, a, x[4], 0xe7d3fbc8, 20);
    STEP(G, a, b, c, d, x[9], 0x21e1cde6, 5);
    STEP(G, d, a, b, c, x[14], 0xc33707d6, 9);
    STEP(G, c, d, a, b, x[3], 0xf4d50d87, 14);
    STEP(G, b, c, d, a, x[8], 0x455a14ed, 20);
    STEP(G, a, b, c, d, x[13], 0xa9e3e905, 5);
    STEP(G, d, a, b, c, x[2], 0xfcefa3f8, 9);
    STEP(G, c, d, a, b, x[7], 0x676f02d9, 14);
    STEP(G, b, c, d, a, x[12], 0x8d2a4c8a, 20);

    // Round 3
    STEP(H, a, b, c, d, x[5], 0xfffa3942, 4);
    STEP(H, d, a, b, c, x[8], 0x8771f681, 11);
    STEP(H, c, d, a, b, x[11], 0x6d9d6122, 16);
    STEP(H, b, c, d, a, x[14], 0xfde5380c, 23);
    STEP(H, a, b, c, d, x[1], 0xa4beea44, 4);
    STEP(H, d, a, b, c, x[4], 0x4bdecfa9, 11);
    STEP(H, c, d, a, b, x[7], 0xf6bb4b60, 16);
    STEP(H, b, c, d, a, x[10], 0xbebfbc70, 23);
    STEP(H, a, b, c, d, x[13], 0x289b7ec6, 4);
    STEP(H, d, a, b, c, x[0], 0xeaa127fa, 11);
    STEP(H, c, d, a, b, x[3], 0xd4ef3085, 16);
    STEP(H, b, c, d, a, x[6], 0x04881d05, 23);
    STEP(H, a, b, c, d, x[9], 0xd9d4d039, 4);
    STEP(H, d, a, b, c, x[12], 0xe6db99e5, 11);
    STEP(H, c, d, a, b, x[15], 0x1fa27cf8, 16);
    STEP(H, b, c, d, a, x[2], 0xc4ac5665, 23);

    // Round 4
    STEP(I, a, b, c, d, x[0], 0xf4292244, 6);
    STEP(I, d, a, b, c, x[7], 0x432aff97, 10);
    STEP(I, c, d, a, b, x[14], 0xab9423a7, 15);
    STEP(I, b, c, d, a, x[5], 0xfc93a039, 21);
    STEP(I, a, b, c, d, x[12], 0x655b59c3, 6);
    STEP(I, d, a, b, c, x[3], 0x8f0ccc92, 10);
    STEP(I, c, d, a, b, x[10], 0xffeff47d, 15);
    STEP(I, b, c, d, a, x[1], 0x85845dd1, 21);
    STEP(I, a, b, c, d, x[8], 0x6fa87e4f, 6);
    STEP(I, d, a, b, c, x[15], 0xfe2ce6e0, 10);
    STEP(I, c, d, a, b, x[6], 0xa3014314, 15);
    STEP(I, b, c, d, a, x[13], 0x4e0811a1, 21);
    STEP(I, a, b, c, d, x[4], 0xf7537e82, 6);
    STEP(I, d, a, b, c, x[11], 0xbd3af235, 10);
    STEP(I, c, d, a, b, x[2], 0x2ad7d2bb, 15);
    STEP(I, b, c, d, a, x[9], 0xeb86d391, 21);

    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
}

void md5Init(MD5Context *ctx) {
    ctx->size = 0;
    ctx->buffer[0] = 0x67452301;
    ctx->buffer[1] = 0xefcdab89;
    ctx->buffer[2] = 0x98badcfe;
    ctx->buffer[3] = 0x10325476;
}

void md5Update(MD5Context *ctx, const uint8_t *input, size_t inputLen) {
    size_t i, index, partLen;
    index = (size_t)((ctx->size >> 3) & 0x3f);
    ctx->size += (uint64_t)inputLen * 8;
    partLen = 64 - index;

    if (inputLen >= partLen) {
        memcpy(&ctx->input[index], input, partLen);
        md5Transform(ctx->buffer, ctx->input);
        for (i = partLen; i + 63 < inputLen; i += 64)
            md5Transform(ctx->buffer, &input[i]);
        index = 0;
    } else {
        i = 0;
    }
    memcpy(&ctx->input[index], &input[i], inputLen - i);
}

void md5Final(uint8_t digest[16], MD5Context *ctx) {
    uint8_t bits[8];
    size_t index, padLen;
    static const uint8_t PADDING[64] = {0x80}; // Remaining zeros implicit

    // Save number of bits
    for (int i = 0; i < 8; i++)
        bits[i] = (uint8_t)((ctx->size >> (i * 8)) & 0xff);

    index = (size_t)((ctx->size >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    md5Update(ctx, PADDING, padLen);
    md5Update(ctx, bits, 8);

    // Encode state into digest
    for (int i = 0; i < 16; i++)
        digest[i] = (uint8_t)((ctx->buffer[i >> 2] >> ((i & 3) * 8)) & 0xff);
}
// --- MD5 Implementation End ---

void print_hash(uint8_t *digest) {
    for (int i = 0; i < 16; i++) printf("%02x", digest[i]);
    printf("\n");
}

int main() {
    char str1[] = "Six slippery snails slid slowly seaward.";
    char str2[] = "Six silppery snails slid slowly seaward."; // Typo 'silppery'
    
    uint8_t hash1[16], hash2[16];
    MD5Context ctx;

    printf("String 1: %s\n", str1);
    md5Init(&ctx);
    md5Update(&ctx, (uint8_t*)str1, strlen(str1));
    md5Final(hash1, &ctx);
    printf("MD5: ");
    print_hash(hash1);

    printf("\nString 2: %s\n", str2);
    md5Init(&ctx);
    md5Update(&ctx, (uint8_t*)str2, strlen(str2));
    md5Final(hash2, &ctx);
    printf("MD5: ");
    print_hash(hash2);

    // Compare
    int same = 1;
    for(int i=0; i<16; i++) if(hash1[i] != hash2[i]) same = 0;

    printf("\nConclusion: The MD5 checksums are %s.\n", same ? "IDENTICAL" : "DIFFERENT");
    if (!same) printf("(Even a small change in input creates a completely different hash)\n");

    return 0;
}